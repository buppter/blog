---
title: MySQL 锁机制
date: 2019-07-20 16:50:46
categories: 数据库
tags: 
    - MySQL
    - 锁
---
锁定机制的优劣直接应想到一个数据库系统的并发处理能力和性能，所以锁定机制的实现也就成为了各种数据库的核心技术之一。本章将对 MySQL 中两种使用最为频繁的存储引擎 `MyISAM` 和 `InnoDB` 各自的锁定机制进行较为详细的分析。
<!--more-->

## 一、锁的分类
#### 1. 从数据操作类型来分
- 读锁(共享锁)  
针对同一份数据，多个读操作可以同时进行而互不影响
- 写锁(排它锁)  
当前写操作没有完成前，它会阻断其他写锁和读锁

#### 2. 对数据操作的粒度区分
- 行锁
- 表锁

## 二、表锁(偏读)
#### 1. 特点
偏向 `MyISAM` 存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度低。
#### 2. 案例分析

##### 2.1 建表SQL

```sql
CREATE TABLE  mylock(
    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(32)
)ENGINE MyISAM;
```
##### 2.2 查看表是否存在锁
```sql
SHOW OPEN TABLES;

# 返回信息示例
+--------------------+-----------------------------------+--------+-------------+
| Database           | Table                             | In_use | Name_locked |
+--------------------+-----------------------------------+--------+-------------+
| Database_name      | table_name                        |      0 |           0 |
+--------------------+-----------------------------------+--------+-------------+
```
`0` 即代表没有锁

##### 2.3 手动增加表锁
```sql
LOCK TABLE table_name_1 READ(WRITE) [,table_name_2 READ(WRITE), ...] ;
```

我们手动给 `mylock` 增加读锁，给 `t_user` 增加写锁，再次执行 `SHOW OPEN TABLE`
```sql
+--------------------+-----------------------------------+--------+-------------+
| Database           | Table                             | In_use | Name_locked |
+--------------------+-----------------------------------+--------+-------------+
| test               | mylock                            |      1 |           0 |
+--------------------+-----------------------------------+--------+-------------+
| test               | t_user                            |      1 |           0 |
+--------------------+-----------------------------------+--------+-------------+
```

##### 2.4 释放表锁
```sql
UNLOCK TABLES;
```
##### 2.5 案例1
我们为 `mylock` 增加读锁( `MyISAM` 引擎)
session 1 | session 2
---|---
获取表 `mylock` 的 `READ` 锁定 | 连接MySQL
当前 session 可以查询该表记录 | 其他 session 也可以查询该表记录
当前 session 不能查看其他没有锁定的表 | 其他 session 可以查看或更新为锁定的表
当前 session 中插入或者更新锁定的表都会提示错误| 其他 session 插入或者更新锁定表会一直等会获得锁
释放锁|session 2 获得锁，完成插入或更新操作

##### 2.6 案例2
我们为 `mylock` 增加写锁( `MyISAM` 引擎)
session 1 | session 2
---|---
获得表 `mylcok` 的 `WRITE` 锁定| 待 session 1 开启写锁后，session 2 连接MySQL
当前 session 对锁定表的查询、更新、插入都可以操作|其他 session 对锁定表的查询、更新、插入被阻塞，需要等待锁被释放
释放锁|session 2 获得锁，完成查询、更新、插入操作

#### 3. 总结
对 `MyISAM` 表进行操作，会有以下情况发生：
- 对 `MyISAM` 表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。
- 对 `MyISAM` 表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。

**简而言之，就是读锁会阻塞写，但不会阻塞读。而写锁会把读和写都阻塞。**

#### 4. 表锁分析
可以通过检查 `Table_locks_immediate` 和 `Table_locks_waited` 状态变量来分析系统上的表锁定。
```sql
SHOW STATUS LIKE 'table_lock%';

# 返回信息
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Table_locks_immediate | 147   |
| Table_locks_waited    | 0     |
+-----------------------+-------+
```
两个变量说明如下：
- Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁，值加1
- Table_locks_waited：出现所及锁定而发生等待的次数（不能立即获取锁的次数，每等待一次锁，值加1），此值高说明存在着较严重的表级锁争用的情况。

**此外， `MyISAM` 的读写锁调度室写优先，这也是 `MyISAM` 不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使得查询很难得到锁，从而造成永远阻塞。**

## 三、行锁(偏写)
#### 1. 特点
偏向 `InnoDB` 引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
 `MyISAM` 和 `InnoDB` 的最大两个不同点： 一是 `InnoDB` 支持事务，二是采用了行级锁。
 
#### 2. 案例分析
##### 2.1 建表SQL
```sql
CREATE TABLE t_innodb_lock (
	a int,
	b varchar(16)
) ENGINE = InnoDB;

ALTER TABLE t_innodb_lock
	ADD INDEX index_inndb_a (a);

ALTER TABLE t_innodb_lock
	ADD INDEX index_inndb_b (b);
```

##### 2.2 行锁基本演示

session 1 | session 2
---|---
关闭 `autocommit`|关闭 `autocommit`
更新数据，但没有提提交 `commit`|session 2 对同一行数据进行更新操作被阻塞，只能等待。对其他行数据进行操作不会阻塞
`commit` 提交|接触阻塞，更新操作正常进行  
\ | 提交 `commit`

##### 2.3 索引失效或无索引会导致行锁会升级为表锁
##### 2.4 间隙锁危害
- 什么是间隙锁：  
当我们用范围条件而不是相等条件检索数据，并请求共享和排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做「间隙(GAP)」，InnoDB 会对这个「间隙」加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)
- 危害  
因为 Query 执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。

间隙锁有一个比较致命的弱点，就是当锁定一个范围键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的数据。在某些场景下可能队徽性能造成很大的伤害。

#### 3. 如何锁定一行

```sql
BEGIN;
SELECT * FROM table_name WHERE id = xxx FOR UPDATE
```
这样我们就可以锁定一行数据，当执行 `commit` 或 `rollback` 后就会被释放。

#### 4. 案例结论
`InnoDB` 存储引擎由于实现了行级锁定，虽然在锁定的机制实现方面所带来的性能损耗可能比表级锁会更高一些，但是在整体并发处理能力方面要远远优于 `MyISAM` 的表级锁定。当系统并发量较高的时候，`InnoDB` 的整体性能和 `MyISAM` 相比就会有比较明显的优势了。

但是，`InnoDB` 的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让 `InnoDB` 的整体性能表现不仅不能比 `MyISAM` 高，甚至会更差。

#### 5. 行锁分析
通过检查 `InnoDB_row_lock` 状态变量来分析系统上的行锁争夺情况。
```sql
SHOW STATUS LIKE 'innodb_row_lock%';

# 返回信息示例
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 57011 |
| Innodb_row_lock_time_avg      | 28505 |
| Innodb_row_lock_time_max      | 30841 |
| Innodb_row_lock_waits         | 2     |
+-------------------------------+-------+
```
各个转态变量说明：
- Innodb_row_lock_current_waits：当前正在等待锁定的数量
- Innodb_row_lock_time：从系统启动到现在锁定总时长
- Innodb_row_lock_time_avg：每次等待所花费的平均时长
- Innodb_row_lock_time_max：从系统启动到现在锁定最长一次的等待时间
- Innodb_row_lock_waits：从系统启动到现在总共等待的次数

对于这五个参数，比较重要的是：  
- Innodb_row_lock_time
- Innodb_row_lock_time_avg
- Innodb_row_lock_waits

#### 6. 优化建议
- 尽可能让所有的数据检索通过索引来完成，避免无索引或索引失效导致行锁升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能较少检索条件，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可能低级别事务隔离

## 四、页锁
开销和加锁时间介于表锁和行锁之间，会出现死锁；锁定粒度介于行锁和表锁之间，并发度一般